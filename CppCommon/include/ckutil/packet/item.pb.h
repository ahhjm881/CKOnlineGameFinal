// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: item.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_item_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_item_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_item_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_item_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_item_2eproto;
namespace CKPacket {
class itemInfo;
struct itemInfoDefaultTypeInternal;
extern itemInfoDefaultTypeInternal _itemInfo_default_instance_;
class reqAddToItem;
struct reqAddToItemDefaultTypeInternal;
extern reqAddToItemDefaultTypeInternal _reqAddToItem_default_instance_;
class reqInventoryItems;
struct reqInventoryItemsDefaultTypeInternal;
extern reqInventoryItemsDefaultTypeInternal _reqInventoryItems_default_instance_;
class reqNotifyPlayerName;
struct reqNotifyPlayerNameDefaultTypeInternal;
extern reqNotifyPlayerNameDefaultTypeInternal _reqNotifyPlayerName_default_instance_;
class reqPing;
struct reqPingDefaultTypeInternal;
extern reqPingDefaultTypeInternal _reqPing_default_instance_;
class reqPlayerPosition;
struct reqPlayerPositionDefaultTypeInternal;
extern reqPlayerPositionDefaultTypeInternal _reqPlayerPosition_default_instance_;
class reqRemoveFromItem;
struct reqRemoveFromItemDefaultTypeInternal;
extern reqRemoveFromItemDefaultTypeInternal _reqRemoveFromItem_default_instance_;
class reqReplicatedPlayerDes;
struct reqReplicatedPlayerDesDefaultTypeInternal;
extern reqReplicatedPlayerDesDefaultTypeInternal _reqReplicatedPlayerDes_default_instance_;
class reqReplicatedPlayerGen;
struct reqReplicatedPlayerGenDefaultTypeInternal;
extern reqReplicatedPlayerGenDefaultTypeInternal _reqReplicatedPlayerGen_default_instance_;
class reqShopBuy;
struct reqShopBuyDefaultTypeInternal;
extern reqShopBuyDefaultTypeInternal _reqShopBuy_default_instance_;
class reqShopItemList;
struct reqShopItemListDefaultTypeInternal;
extern reqShopItemListDefaultTypeInternal _reqShopItemList_default_instance_;
class reqShopSell;
struct reqShopSellDefaultTypeInternal;
extern reqShopSellDefaultTypeInternal _reqShopSell_default_instance_;
class resAddToItem;
struct resAddToItemDefaultTypeInternal;
extern resAddToItemDefaultTypeInternal _resAddToItem_default_instance_;
class resInventoryItems;
struct resInventoryItemsDefaultTypeInternal;
extern resInventoryItemsDefaultTypeInternal _resInventoryItems_default_instance_;
class resPing;
struct resPingDefaultTypeInternal;
extern resPingDefaultTypeInternal _resPing_default_instance_;
class resPlayerJoin;
struct resPlayerJoinDefaultTypeInternal;
extern resPlayerJoinDefaultTypeInternal _resPlayerJoin_default_instance_;
class resPlayerPosition;
struct resPlayerPositionDefaultTypeInternal;
extern resPlayerPositionDefaultTypeInternal _resPlayerPosition_default_instance_;
class resRemoveFromToItem;
struct resRemoveFromToItemDefaultTypeInternal;
extern resRemoveFromToItemDefaultTypeInternal _resRemoveFromToItem_default_instance_;
class resReplicatedPlayerDes;
struct resReplicatedPlayerDesDefaultTypeInternal;
extern resReplicatedPlayerDesDefaultTypeInternal _resReplicatedPlayerDes_default_instance_;
class resReplicatedPlayerGen;
struct resReplicatedPlayerGenDefaultTypeInternal;
extern resReplicatedPlayerGenDefaultTypeInternal _resReplicatedPlayerGen_default_instance_;
class resShopBuy;
struct resShopBuyDefaultTypeInternal;
extern resShopBuyDefaultTypeInternal _resShopBuy_default_instance_;
class resShopItemList;
struct resShopItemListDefaultTypeInternal;
extern resShopItemListDefaultTypeInternal _resShopItemList_default_instance_;
class resShopSell;
struct resShopSellDefaultTypeInternal;
extern resShopSellDefaultTypeInternal _resShopSell_default_instance_;
class shopItem;
struct shopItemDefaultTypeInternal;
extern shopItemDefaultTypeInternal _shopItem_default_instance_;
}  // namespace CKPacket
PROTOBUF_NAMESPACE_OPEN
template<> ::CKPacket::itemInfo* Arena::CreateMaybeMessage<::CKPacket::itemInfo>(Arena*);
template<> ::CKPacket::reqAddToItem* Arena::CreateMaybeMessage<::CKPacket::reqAddToItem>(Arena*);
template<> ::CKPacket::reqInventoryItems* Arena::CreateMaybeMessage<::CKPacket::reqInventoryItems>(Arena*);
template<> ::CKPacket::reqNotifyPlayerName* Arena::CreateMaybeMessage<::CKPacket::reqNotifyPlayerName>(Arena*);
template<> ::CKPacket::reqPing* Arena::CreateMaybeMessage<::CKPacket::reqPing>(Arena*);
template<> ::CKPacket::reqPlayerPosition* Arena::CreateMaybeMessage<::CKPacket::reqPlayerPosition>(Arena*);
template<> ::CKPacket::reqRemoveFromItem* Arena::CreateMaybeMessage<::CKPacket::reqRemoveFromItem>(Arena*);
template<> ::CKPacket::reqReplicatedPlayerDes* Arena::CreateMaybeMessage<::CKPacket::reqReplicatedPlayerDes>(Arena*);
template<> ::CKPacket::reqReplicatedPlayerGen* Arena::CreateMaybeMessage<::CKPacket::reqReplicatedPlayerGen>(Arena*);
template<> ::CKPacket::reqShopBuy* Arena::CreateMaybeMessage<::CKPacket::reqShopBuy>(Arena*);
template<> ::CKPacket::reqShopItemList* Arena::CreateMaybeMessage<::CKPacket::reqShopItemList>(Arena*);
template<> ::CKPacket::reqShopSell* Arena::CreateMaybeMessage<::CKPacket::reqShopSell>(Arena*);
template<> ::CKPacket::resAddToItem* Arena::CreateMaybeMessage<::CKPacket::resAddToItem>(Arena*);
template<> ::CKPacket::resInventoryItems* Arena::CreateMaybeMessage<::CKPacket::resInventoryItems>(Arena*);
template<> ::CKPacket::resPing* Arena::CreateMaybeMessage<::CKPacket::resPing>(Arena*);
template<> ::CKPacket::resPlayerJoin* Arena::CreateMaybeMessage<::CKPacket::resPlayerJoin>(Arena*);
template<> ::CKPacket::resPlayerPosition* Arena::CreateMaybeMessage<::CKPacket::resPlayerPosition>(Arena*);
template<> ::CKPacket::resRemoveFromToItem* Arena::CreateMaybeMessage<::CKPacket::resRemoveFromToItem>(Arena*);
template<> ::CKPacket::resReplicatedPlayerDes* Arena::CreateMaybeMessage<::CKPacket::resReplicatedPlayerDes>(Arena*);
template<> ::CKPacket::resReplicatedPlayerGen* Arena::CreateMaybeMessage<::CKPacket::resReplicatedPlayerGen>(Arena*);
template<> ::CKPacket::resShopBuy* Arena::CreateMaybeMessage<::CKPacket::resShopBuy>(Arena*);
template<> ::CKPacket::resShopItemList* Arena::CreateMaybeMessage<::CKPacket::resShopItemList>(Arena*);
template<> ::CKPacket::resShopSell* Arena::CreateMaybeMessage<::CKPacket::resShopSell>(Arena*);
template<> ::CKPacket::shopItem* Arena::CreateMaybeMessage<::CKPacket::shopItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CKPacket {

// ===================================================================

class resPlayerJoin final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CKPacket.resPlayerJoin) */ {
 public:
  inline resPlayerJoin() : resPlayerJoin(nullptr) {}
  explicit PROTOBUF_CONSTEXPR resPlayerJoin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resPlayerJoin(const resPlayerJoin& from);
  resPlayerJoin(resPlayerJoin&& from) noexcept
    : resPlayerJoin() {
    *this = ::std::move(from);
  }

  inline resPlayerJoin& operator=(const resPlayerJoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline resPlayerJoin& operator=(resPlayerJoin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resPlayerJoin& default_instance() {
    return *internal_default_instance();
  }
  static inline const resPlayerJoin* internal_default_instance() {
    return reinterpret_cast<const resPlayerJoin*>(
               &_resPlayerJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(resPlayerJoin& a, resPlayerJoin& b) {
    a.Swap(&b);
  }
  inline void Swap(resPlayerJoin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resPlayerJoin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resPlayerJoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resPlayerJoin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const resPlayerJoin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const resPlayerJoin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resPlayerJoin";
  }
  protected:
  explicit resPlayerJoin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKPacket.resPlayerJoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqPing final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CKPacket.reqPing) */ {
 public:
  inline reqPing() : reqPing(nullptr) {}
  explicit PROTOBUF_CONSTEXPR reqPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqPing(const reqPing& from);
  reqPing(reqPing&& from) noexcept
    : reqPing() {
    *this = ::std::move(from);
  }

  inline reqPing& operator=(const reqPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqPing& operator=(reqPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqPing* internal_default_instance() {
    return reinterpret_cast<const reqPing*>(
               &_reqPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(reqPing& a, reqPing& b) {
    a.Swap(&b);
  }
  inline void Swap(reqPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const reqPing& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const reqPing& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqPing";
  }
  protected:
  explicit reqPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKPacket.reqPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resPing final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CKPacket.resPing) */ {
 public:
  inline resPing() : resPing(nullptr) {}
  explicit PROTOBUF_CONSTEXPR resPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resPing(const resPing& from);
  resPing(resPing&& from) noexcept
    : resPing() {
    *this = ::std::move(from);
  }

  inline resPing& operator=(const resPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline resPing& operator=(resPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const resPing* internal_default_instance() {
    return reinterpret_cast<const resPing*>(
               &_resPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(resPing& a, resPing& b) {
    a.Swap(&b);
  }
  inline void Swap(resPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const resPing& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const resPing& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resPing";
  }
  protected:
  explicit resPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKPacket.resPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqNotifyPlayerName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqNotifyPlayerName) */ {
 public:
  inline reqNotifyPlayerName() : reqNotifyPlayerName(nullptr) {}
  ~reqNotifyPlayerName() override;
  explicit PROTOBUF_CONSTEXPR reqNotifyPlayerName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqNotifyPlayerName(const reqNotifyPlayerName& from);
  reqNotifyPlayerName(reqNotifyPlayerName&& from) noexcept
    : reqNotifyPlayerName() {
    *this = ::std::move(from);
  }

  inline reqNotifyPlayerName& operator=(const reqNotifyPlayerName& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqNotifyPlayerName& operator=(reqNotifyPlayerName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqNotifyPlayerName& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqNotifyPlayerName* internal_default_instance() {
    return reinterpret_cast<const reqNotifyPlayerName*>(
               &_reqNotifyPlayerName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(reqNotifyPlayerName& a, reqNotifyPlayerName& b) {
    a.Swap(&b);
  }
  inline void Swap(reqNotifyPlayerName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqNotifyPlayerName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqNotifyPlayerName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqNotifyPlayerName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqNotifyPlayerName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqNotifyPlayerName& from) {
    reqNotifyPlayerName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqNotifyPlayerName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqNotifyPlayerName";
  }
  protected:
  explicit reqNotifyPlayerName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.reqNotifyPlayerName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqPlayerPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqPlayerPosition) */ {
 public:
  inline reqPlayerPosition() : reqPlayerPosition(nullptr) {}
  ~reqPlayerPosition() override;
  explicit PROTOBUF_CONSTEXPR reqPlayerPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqPlayerPosition(const reqPlayerPosition& from);
  reqPlayerPosition(reqPlayerPosition&& from) noexcept
    : reqPlayerPosition() {
    *this = ::std::move(from);
  }

  inline reqPlayerPosition& operator=(const reqPlayerPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqPlayerPosition& operator=(reqPlayerPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqPlayerPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqPlayerPosition* internal_default_instance() {
    return reinterpret_cast<const reqPlayerPosition*>(
               &_reqPlayerPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(reqPlayerPosition& a, reqPlayerPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(reqPlayerPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqPlayerPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqPlayerPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqPlayerPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqPlayerPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqPlayerPosition& from) {
    reqPlayerPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqPlayerPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqPlayerPosition";
  }
  protected:
  explicit reqPlayerPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kIndexFieldNumber = 4,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // optional int32 index = 4;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.reqPlayerPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resPlayerPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resPlayerPosition) */ {
 public:
  inline resPlayerPosition() : resPlayerPosition(nullptr) {}
  ~resPlayerPosition() override;
  explicit PROTOBUF_CONSTEXPR resPlayerPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resPlayerPosition(const resPlayerPosition& from);
  resPlayerPosition(resPlayerPosition&& from) noexcept
    : resPlayerPosition() {
    *this = ::std::move(from);
  }

  inline resPlayerPosition& operator=(const resPlayerPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline resPlayerPosition& operator=(resPlayerPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resPlayerPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const resPlayerPosition* internal_default_instance() {
    return reinterpret_cast<const resPlayerPosition*>(
               &_resPlayerPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(resPlayerPosition& a, resPlayerPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(resPlayerPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resPlayerPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resPlayerPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resPlayerPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resPlayerPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resPlayerPosition& from) {
    resPlayerPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resPlayerPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resPlayerPosition";
  }
  protected:
  explicit resPlayerPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kIndexFieldNumber = 4,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // optional int32 index = 4;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.resPlayerPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resReplicatedPlayerGen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resReplicatedPlayerGen) */ {
 public:
  inline resReplicatedPlayerGen() : resReplicatedPlayerGen(nullptr) {}
  ~resReplicatedPlayerGen() override;
  explicit PROTOBUF_CONSTEXPR resReplicatedPlayerGen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resReplicatedPlayerGen(const resReplicatedPlayerGen& from);
  resReplicatedPlayerGen(resReplicatedPlayerGen&& from) noexcept
    : resReplicatedPlayerGen() {
    *this = ::std::move(from);
  }

  inline resReplicatedPlayerGen& operator=(const resReplicatedPlayerGen& from) {
    CopyFrom(from);
    return *this;
  }
  inline resReplicatedPlayerGen& operator=(resReplicatedPlayerGen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resReplicatedPlayerGen& default_instance() {
    return *internal_default_instance();
  }
  static inline const resReplicatedPlayerGen* internal_default_instance() {
    return reinterpret_cast<const resReplicatedPlayerGen*>(
               &_resReplicatedPlayerGen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(resReplicatedPlayerGen& a, resReplicatedPlayerGen& b) {
    a.Swap(&b);
  }
  inline void Swap(resReplicatedPlayerGen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resReplicatedPlayerGen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resReplicatedPlayerGen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resReplicatedPlayerGen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resReplicatedPlayerGen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resReplicatedPlayerGen& from) {
    resReplicatedPlayerGen::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resReplicatedPlayerGen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resReplicatedPlayerGen";
  }
  protected:
  explicit resReplicatedPlayerGen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // optional int32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.resReplicatedPlayerGen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resReplicatedPlayerDes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resReplicatedPlayerDes) */ {
 public:
  inline resReplicatedPlayerDes() : resReplicatedPlayerDes(nullptr) {}
  ~resReplicatedPlayerDes() override;
  explicit PROTOBUF_CONSTEXPR resReplicatedPlayerDes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resReplicatedPlayerDes(const resReplicatedPlayerDes& from);
  resReplicatedPlayerDes(resReplicatedPlayerDes&& from) noexcept
    : resReplicatedPlayerDes() {
    *this = ::std::move(from);
  }

  inline resReplicatedPlayerDes& operator=(const resReplicatedPlayerDes& from) {
    CopyFrom(from);
    return *this;
  }
  inline resReplicatedPlayerDes& operator=(resReplicatedPlayerDes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resReplicatedPlayerDes& default_instance() {
    return *internal_default_instance();
  }
  static inline const resReplicatedPlayerDes* internal_default_instance() {
    return reinterpret_cast<const resReplicatedPlayerDes*>(
               &_resReplicatedPlayerDes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(resReplicatedPlayerDes& a, resReplicatedPlayerDes& b) {
    a.Swap(&b);
  }
  inline void Swap(resReplicatedPlayerDes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resReplicatedPlayerDes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resReplicatedPlayerDes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resReplicatedPlayerDes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resReplicatedPlayerDes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resReplicatedPlayerDes& from) {
    resReplicatedPlayerDes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resReplicatedPlayerDes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resReplicatedPlayerDes";
  }
  protected:
  explicit resReplicatedPlayerDes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // optional int32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.resReplicatedPlayerDes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqReplicatedPlayerGen final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CKPacket.reqReplicatedPlayerGen) */ {
 public:
  inline reqReplicatedPlayerGen() : reqReplicatedPlayerGen(nullptr) {}
  explicit PROTOBUF_CONSTEXPR reqReplicatedPlayerGen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqReplicatedPlayerGen(const reqReplicatedPlayerGen& from);
  reqReplicatedPlayerGen(reqReplicatedPlayerGen&& from) noexcept
    : reqReplicatedPlayerGen() {
    *this = ::std::move(from);
  }

  inline reqReplicatedPlayerGen& operator=(const reqReplicatedPlayerGen& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqReplicatedPlayerGen& operator=(reqReplicatedPlayerGen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqReplicatedPlayerGen& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqReplicatedPlayerGen* internal_default_instance() {
    return reinterpret_cast<const reqReplicatedPlayerGen*>(
               &_reqReplicatedPlayerGen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(reqReplicatedPlayerGen& a, reqReplicatedPlayerGen& b) {
    a.Swap(&b);
  }
  inline void Swap(reqReplicatedPlayerGen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqReplicatedPlayerGen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqReplicatedPlayerGen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqReplicatedPlayerGen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const reqReplicatedPlayerGen& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const reqReplicatedPlayerGen& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqReplicatedPlayerGen";
  }
  protected:
  explicit reqReplicatedPlayerGen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKPacket.reqReplicatedPlayerGen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqReplicatedPlayerDes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqReplicatedPlayerDes) */ {
 public:
  inline reqReplicatedPlayerDes() : reqReplicatedPlayerDes(nullptr) {}
  ~reqReplicatedPlayerDes() override;
  explicit PROTOBUF_CONSTEXPR reqReplicatedPlayerDes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqReplicatedPlayerDes(const reqReplicatedPlayerDes& from);
  reqReplicatedPlayerDes(reqReplicatedPlayerDes&& from) noexcept
    : reqReplicatedPlayerDes() {
    *this = ::std::move(from);
  }

  inline reqReplicatedPlayerDes& operator=(const reqReplicatedPlayerDes& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqReplicatedPlayerDes& operator=(reqReplicatedPlayerDes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqReplicatedPlayerDes& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqReplicatedPlayerDes* internal_default_instance() {
    return reinterpret_cast<const reqReplicatedPlayerDes*>(
               &_reqReplicatedPlayerDes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(reqReplicatedPlayerDes& a, reqReplicatedPlayerDes& b) {
    a.Swap(&b);
  }
  inline void Swap(reqReplicatedPlayerDes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqReplicatedPlayerDes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqReplicatedPlayerDes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqReplicatedPlayerDes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqReplicatedPlayerDes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqReplicatedPlayerDes& from) {
    reqReplicatedPlayerDes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqReplicatedPlayerDes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqReplicatedPlayerDes";
  }
  protected:
  explicit reqReplicatedPlayerDes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // optional int32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.reqReplicatedPlayerDes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqAddToItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqAddToItem) */ {
 public:
  inline reqAddToItem() : reqAddToItem(nullptr) {}
  ~reqAddToItem() override;
  explicit PROTOBUF_CONSTEXPR reqAddToItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqAddToItem(const reqAddToItem& from);
  reqAddToItem(reqAddToItem&& from) noexcept
    : reqAddToItem() {
    *this = ::std::move(from);
  }

  inline reqAddToItem& operator=(const reqAddToItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqAddToItem& operator=(reqAddToItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqAddToItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqAddToItem* internal_default_instance() {
    return reinterpret_cast<const reqAddToItem*>(
               &_reqAddToItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(reqAddToItem& a, reqAddToItem& b) {
    a.Swap(&b);
  }
  inline void Swap(reqAddToItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqAddToItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqAddToItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqAddToItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqAddToItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqAddToItem& from) {
    reqAddToItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqAddToItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqAddToItem";
  }
  protected:
  explicit reqAddToItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .CKPacket.itemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::CKPacket::itemInfo& item() const;
  PROTOBUF_NODISCARD ::CKPacket::itemInfo* release_item();
  ::CKPacket::itemInfo* mutable_item();
  void set_allocated_item(::CKPacket::itemInfo* item);
  private:
  const ::CKPacket::itemInfo& _internal_item() const;
  ::CKPacket::itemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::CKPacket::itemInfo* item);
  ::CKPacket::itemInfo* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:CKPacket.reqAddToItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CKPacket::itemInfo* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resAddToItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resAddToItem) */ {
 public:
  inline resAddToItem() : resAddToItem(nullptr) {}
  ~resAddToItem() override;
  explicit PROTOBUF_CONSTEXPR resAddToItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resAddToItem(const resAddToItem& from);
  resAddToItem(resAddToItem&& from) noexcept
    : resAddToItem() {
    *this = ::std::move(from);
  }

  inline resAddToItem& operator=(const resAddToItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline resAddToItem& operator=(resAddToItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resAddToItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const resAddToItem* internal_default_instance() {
    return reinterpret_cast<const resAddToItem*>(
               &_resAddToItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(resAddToItem& a, resAddToItem& b) {
    a.Swap(&b);
  }
  inline void Swap(resAddToItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resAddToItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resAddToItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resAddToItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resAddToItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resAddToItem& from) {
    resAddToItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resAddToItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resAddToItem";
  }
  protected:
  explicit resAddToItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .CKPacket.itemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::CKPacket::itemInfo& item() const;
  PROTOBUF_NODISCARD ::CKPacket::itemInfo* release_item();
  ::CKPacket::itemInfo* mutable_item();
  void set_allocated_item(::CKPacket::itemInfo* item);
  private:
  const ::CKPacket::itemInfo& _internal_item() const;
  ::CKPacket::itemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::CKPacket::itemInfo* item);
  ::CKPacket::itemInfo* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:CKPacket.resAddToItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CKPacket::itemInfo* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqRemoveFromItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqRemoveFromItem) */ {
 public:
  inline reqRemoveFromItem() : reqRemoveFromItem(nullptr) {}
  ~reqRemoveFromItem() override;
  explicit PROTOBUF_CONSTEXPR reqRemoveFromItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqRemoveFromItem(const reqRemoveFromItem& from);
  reqRemoveFromItem(reqRemoveFromItem&& from) noexcept
    : reqRemoveFromItem() {
    *this = ::std::move(from);
  }

  inline reqRemoveFromItem& operator=(const reqRemoveFromItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqRemoveFromItem& operator=(reqRemoveFromItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqRemoveFromItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqRemoveFromItem* internal_default_instance() {
    return reinterpret_cast<const reqRemoveFromItem*>(
               &_reqRemoveFromItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(reqRemoveFromItem& a, reqRemoveFromItem& b) {
    a.Swap(&b);
  }
  inline void Swap(reqRemoveFromItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqRemoveFromItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqRemoveFromItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqRemoveFromItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqRemoveFromItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqRemoveFromItem& from) {
    reqRemoveFromItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqRemoveFromItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqRemoveFromItem";
  }
  protected:
  explicit reqRemoveFromItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .CKPacket.itemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::CKPacket::itemInfo& item() const;
  PROTOBUF_NODISCARD ::CKPacket::itemInfo* release_item();
  ::CKPacket::itemInfo* mutable_item();
  void set_allocated_item(::CKPacket::itemInfo* item);
  private:
  const ::CKPacket::itemInfo& _internal_item() const;
  ::CKPacket::itemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::CKPacket::itemInfo* item);
  ::CKPacket::itemInfo* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:CKPacket.reqRemoveFromItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CKPacket::itemInfo* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resRemoveFromToItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resRemoveFromToItem) */ {
 public:
  inline resRemoveFromToItem() : resRemoveFromToItem(nullptr) {}
  ~resRemoveFromToItem() override;
  explicit PROTOBUF_CONSTEXPR resRemoveFromToItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resRemoveFromToItem(const resRemoveFromToItem& from);
  resRemoveFromToItem(resRemoveFromToItem&& from) noexcept
    : resRemoveFromToItem() {
    *this = ::std::move(from);
  }

  inline resRemoveFromToItem& operator=(const resRemoveFromToItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline resRemoveFromToItem& operator=(resRemoveFromToItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resRemoveFromToItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const resRemoveFromToItem* internal_default_instance() {
    return reinterpret_cast<const resRemoveFromToItem*>(
               &_resRemoveFromToItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(resRemoveFromToItem& a, resRemoveFromToItem& b) {
    a.Swap(&b);
  }
  inline void Swap(resRemoveFromToItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resRemoveFromToItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resRemoveFromToItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resRemoveFromToItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resRemoveFromToItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resRemoveFromToItem& from) {
    resRemoveFromToItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resRemoveFromToItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resRemoveFromToItem";
  }
  protected:
  explicit resRemoveFromToItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // .CKPacket.itemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::CKPacket::itemInfo& item() const;
  PROTOBUF_NODISCARD ::CKPacket::itemInfo* release_item();
  ::CKPacket::itemInfo* mutable_item();
  void set_allocated_item(::CKPacket::itemInfo* item);
  private:
  const ::CKPacket::itemInfo& _internal_item() const;
  ::CKPacket::itemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::CKPacket::itemInfo* item);
  ::CKPacket::itemInfo* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:CKPacket.resRemoveFromToItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CKPacket::itemInfo* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqInventoryItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqInventoryItems) */ {
 public:
  inline reqInventoryItems() : reqInventoryItems(nullptr) {}
  ~reqInventoryItems() override;
  explicit PROTOBUF_CONSTEXPR reqInventoryItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqInventoryItems(const reqInventoryItems& from);
  reqInventoryItems(reqInventoryItems&& from) noexcept
    : reqInventoryItems() {
    *this = ::std::move(from);
  }

  inline reqInventoryItems& operator=(const reqInventoryItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqInventoryItems& operator=(reqInventoryItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqInventoryItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqInventoryItems* internal_default_instance() {
    return reinterpret_cast<const reqInventoryItems*>(
               &_reqInventoryItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(reqInventoryItems& a, reqInventoryItems& b) {
    a.Swap(&b);
  }
  inline void Swap(reqInventoryItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqInventoryItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqInventoryItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqInventoryItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqInventoryItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqInventoryItems& from) {
    reqInventoryItems::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqInventoryItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqInventoryItems";
  }
  protected:
  explicit reqInventoryItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.reqInventoryItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resInventoryItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resInventoryItems) */ {
 public:
  inline resInventoryItems() : resInventoryItems(nullptr) {}
  ~resInventoryItems() override;
  explicit PROTOBUF_CONSTEXPR resInventoryItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resInventoryItems(const resInventoryItems& from);
  resInventoryItems(resInventoryItems&& from) noexcept
    : resInventoryItems() {
    *this = ::std::move(from);
  }

  inline resInventoryItems& operator=(const resInventoryItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline resInventoryItems& operator=(resInventoryItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resInventoryItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const resInventoryItems* internal_default_instance() {
    return reinterpret_cast<const resInventoryItems*>(
               &_resInventoryItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(resInventoryItems& a, resInventoryItems& b) {
    a.Swap(&b);
  }
  inline void Swap(resInventoryItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resInventoryItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resInventoryItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resInventoryItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resInventoryItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resInventoryItems& from) {
    resInventoryItems::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resInventoryItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resInventoryItems";
  }
  protected:
  explicit resInventoryItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .CKPacket.itemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::CKPacket::itemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::itemInfo >*
      mutable_items();
  private:
  const ::CKPacket::itemInfo& _internal_items(int index) const;
  ::CKPacket::itemInfo* _internal_add_items();
  public:
  const ::CKPacket::itemInfo& items(int index) const;
  ::CKPacket::itemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::itemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:CKPacket.resInventoryItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::itemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class itemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.itemInfo) */ {
 public:
  inline itemInfo() : itemInfo(nullptr) {}
  ~itemInfo() override;
  explicit PROTOBUF_CONSTEXPR itemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  itemInfo(const itemInfo& from);
  itemInfo(itemInfo&& from) noexcept
    : itemInfo() {
    *this = ::std::move(from);
  }

  inline itemInfo& operator=(const itemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline itemInfo& operator=(itemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const itemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const itemInfo* internal_default_instance() {
    return reinterpret_cast<const itemInfo*>(
               &_itemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(itemInfo& a, itemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(itemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(itemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  itemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<itemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const itemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const itemInfo& from) {
    itemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(itemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.itemInfo";
  }
  protected:
  explicit itemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemNameFieldNumber = 2,
    kItemDescFieldNumber = 3,
    kItemidFieldNumber = 1,
    kCountFieldNumber = 4,
  };
  // string itemName = 2;
  void clear_itemname();
  const std::string& itemname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_itemname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_itemname();
  PROTOBUF_NODISCARD std::string* release_itemname();
  void set_allocated_itemname(std::string* itemname);
  private:
  const std::string& _internal_itemname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_itemname(const std::string& value);
  std::string* _internal_mutable_itemname();
  public:

  // string itemDesc = 3;
  void clear_itemdesc();
  const std::string& itemdesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_itemdesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_itemdesc();
  PROTOBUF_NODISCARD std::string* release_itemdesc();
  void set_allocated_itemdesc(std::string* itemdesc);
  private:
  const std::string& _internal_itemdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_itemdesc(const std::string& value);
  std::string* _internal_mutable_itemdesc();
  public:

  // int32 itemid = 1;
  void clear_itemid();
  int32_t itemid() const;
  void set_itemid(int32_t value);
  private:
  int32_t _internal_itemid() const;
  void _internal_set_itemid(int32_t value);
  public:

  // uint32 count = 4;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.itemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr itemname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr itemdesc_;
    int32_t itemid_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqShopItemList final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CKPacket.reqShopItemList) */ {
 public:
  inline reqShopItemList() : reqShopItemList(nullptr) {}
  explicit PROTOBUF_CONSTEXPR reqShopItemList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqShopItemList(const reqShopItemList& from);
  reqShopItemList(reqShopItemList&& from) noexcept
    : reqShopItemList() {
    *this = ::std::move(from);
  }

  inline reqShopItemList& operator=(const reqShopItemList& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqShopItemList& operator=(reqShopItemList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqShopItemList& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqShopItemList* internal_default_instance() {
    return reinterpret_cast<const reqShopItemList*>(
               &_reqShopItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(reqShopItemList& a, reqShopItemList& b) {
    a.Swap(&b);
  }
  inline void Swap(reqShopItemList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqShopItemList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqShopItemList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqShopItemList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const reqShopItemList& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const reqShopItemList& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqShopItemList";
  }
  protected:
  explicit reqShopItemList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKPacket.reqShopItemList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resShopItemList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resShopItemList) */ {
 public:
  inline resShopItemList() : resShopItemList(nullptr) {}
  ~resShopItemList() override;
  explicit PROTOBUF_CONSTEXPR resShopItemList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resShopItemList(const resShopItemList& from);
  resShopItemList(resShopItemList&& from) noexcept
    : resShopItemList() {
    *this = ::std::move(from);
  }

  inline resShopItemList& operator=(const resShopItemList& from) {
    CopyFrom(from);
    return *this;
  }
  inline resShopItemList& operator=(resShopItemList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resShopItemList& default_instance() {
    return *internal_default_instance();
  }
  static inline const resShopItemList* internal_default_instance() {
    return reinterpret_cast<const resShopItemList*>(
               &_resShopItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(resShopItemList& a, resShopItemList& b) {
    a.Swap(&b);
  }
  inline void Swap(resShopItemList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resShopItemList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resShopItemList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resShopItemList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resShopItemList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resShopItemList& from) {
    resShopItemList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resShopItemList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resShopItemList";
  }
  protected:
  explicit resShopItemList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .CKPacket.shopItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::CKPacket::shopItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::shopItem >*
      mutable_items();
  private:
  const ::CKPacket::shopItem& _internal_items(int index) const;
  ::CKPacket::shopItem* _internal_add_items();
  public:
  const ::CKPacket::shopItem& items(int index) const;
  ::CKPacket::shopItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::shopItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:CKPacket.resShopItemList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::shopItem > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class shopItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.shopItem) */ {
 public:
  inline shopItem() : shopItem(nullptr) {}
  ~shopItem() override;
  explicit PROTOBUF_CONSTEXPR shopItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  shopItem(const shopItem& from);
  shopItem(shopItem&& from) noexcept
    : shopItem() {
    *this = ::std::move(from);
  }

  inline shopItem& operator=(const shopItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline shopItem& operator=(shopItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const shopItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const shopItem* internal_default_instance() {
    return reinterpret_cast<const shopItem*>(
               &_shopItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(shopItem& a, shopItem& b) {
    a.Swap(&b);
  }
  inline void Swap(shopItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(shopItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  shopItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<shopItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const shopItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const shopItem& from) {
    shopItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(shopItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.shopItem";
  }
  protected:
  explicit shopItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemNameFieldNumber = 2,
    kItemDescFieldNumber = 3,
    kItemIdFieldNumber = 1,
    kItemCountFieldNumber = 4,
  };
  // string itemName = 2;
  void clear_itemname();
  const std::string& itemname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_itemname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_itemname();
  PROTOBUF_NODISCARD std::string* release_itemname();
  void set_allocated_itemname(std::string* itemname);
  private:
  const std::string& _internal_itemname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_itemname(const std::string& value);
  std::string* _internal_mutable_itemname();
  public:

  // string itemDesc = 3;
  void clear_itemdesc();
  const std::string& itemdesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_itemdesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_itemdesc();
  PROTOBUF_NODISCARD std::string* release_itemdesc();
  void set_allocated_itemdesc(std::string* itemdesc);
  private:
  const std::string& _internal_itemdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_itemdesc(const std::string& value);
  std::string* _internal_mutable_itemdesc();
  public:

  // int32 itemId = 1;
  void clear_itemid();
  int32_t itemid() const;
  void set_itemid(int32_t value);
  private:
  int32_t _internal_itemid() const;
  void _internal_set_itemid(int32_t value);
  public:

  // int32 itemCount = 4;
  void clear_itemcount();
  int32_t itemcount() const;
  void set_itemcount(int32_t value);
  private:
  int32_t _internal_itemcount() const;
  void _internal_set_itemcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.shopItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr itemname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr itemdesc_;
    int32_t itemid_;
    int32_t itemcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqShopBuy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqShopBuy) */ {
 public:
  inline reqShopBuy() : reqShopBuy(nullptr) {}
  ~reqShopBuy() override;
  explicit PROTOBUF_CONSTEXPR reqShopBuy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqShopBuy(const reqShopBuy& from);
  reqShopBuy(reqShopBuy&& from) noexcept
    : reqShopBuy() {
    *this = ::std::move(from);
  }

  inline reqShopBuy& operator=(const reqShopBuy& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqShopBuy& operator=(reqShopBuy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqShopBuy& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqShopBuy* internal_default_instance() {
    return reinterpret_cast<const reqShopBuy*>(
               &_reqShopBuy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(reqShopBuy& a, reqShopBuy& b) {
    a.Swap(&b);
  }
  inline void Swap(reqShopBuy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqShopBuy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqShopBuy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqShopBuy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqShopBuy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqShopBuy& from) {
    reqShopBuy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqShopBuy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqShopBuy";
  }
  protected:
  explicit reqShopBuy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
    kItemIDFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string playerName = 1;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // int32 itemID = 2;
  void clear_itemid();
  int32_t itemid() const;
  void set_itemid(int32_t value);
  private:
  int32_t _internal_itemid() const;
  void _internal_set_itemid(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.reqShopBuy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    int32_t itemid_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resShopBuy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resShopBuy) */ {
 public:
  inline resShopBuy() : resShopBuy(nullptr) {}
  ~resShopBuy() override;
  explicit PROTOBUF_CONSTEXPR resShopBuy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resShopBuy(const resShopBuy& from);
  resShopBuy(resShopBuy&& from) noexcept
    : resShopBuy() {
    *this = ::std::move(from);
  }

  inline resShopBuy& operator=(const resShopBuy& from) {
    CopyFrom(from);
    return *this;
  }
  inline resShopBuy& operator=(resShopBuy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resShopBuy& default_instance() {
    return *internal_default_instance();
  }
  static inline const resShopBuy* internal_default_instance() {
    return reinterpret_cast<const resShopBuy*>(
               &_resShopBuy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(resShopBuy& a, resShopBuy& b) {
    a.Swap(&b);
  }
  inline void Swap(resShopBuy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resShopBuy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resShopBuy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resShopBuy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resShopBuy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resShopBuy& from) {
    resShopBuy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resShopBuy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resShopBuy";
  }
  protected:
  explicit resShopBuy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.resShopBuy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class reqShopSell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.reqShopSell) */ {
 public:
  inline reqShopSell() : reqShopSell(nullptr) {}
  ~reqShopSell() override;
  explicit PROTOBUF_CONSTEXPR reqShopSell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  reqShopSell(const reqShopSell& from);
  reqShopSell(reqShopSell&& from) noexcept
    : reqShopSell() {
    *this = ::std::move(from);
  }

  inline reqShopSell& operator=(const reqShopSell& from) {
    CopyFrom(from);
    return *this;
  }
  inline reqShopSell& operator=(reqShopSell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const reqShopSell& default_instance() {
    return *internal_default_instance();
  }
  static inline const reqShopSell* internal_default_instance() {
    return reinterpret_cast<const reqShopSell*>(
               &_reqShopSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(reqShopSell& a, reqShopSell& b) {
    a.Swap(&b);
  }
  inline void Swap(reqShopSell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(reqShopSell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  reqShopSell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<reqShopSell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const reqShopSell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const reqShopSell& from) {
    reqShopSell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqShopSell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.reqShopSell";
  }
  protected:
  explicit reqShopSell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
    kItemIDFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string playerName = 1;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // int32 itemID = 2;
  void clear_itemid();
  int32_t itemid() const;
  void set_itemid(int32_t value);
  private:
  int32_t _internal_itemid() const;
  void _internal_set_itemid(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.reqShopSell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    int32_t itemid_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// -------------------------------------------------------------------

class resShopSell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CKPacket.resShopSell) */ {
 public:
  inline resShopSell() : resShopSell(nullptr) {}
  ~resShopSell() override;
  explicit PROTOBUF_CONSTEXPR resShopSell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resShopSell(const resShopSell& from);
  resShopSell(resShopSell&& from) noexcept
    : resShopSell() {
    *this = ::std::move(from);
  }

  inline resShopSell& operator=(const resShopSell& from) {
    CopyFrom(from);
    return *this;
  }
  inline resShopSell& operator=(resShopSell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resShopSell& default_instance() {
    return *internal_default_instance();
  }
  static inline const resShopSell* internal_default_instance() {
    return reinterpret_cast<const resShopSell*>(
               &_resShopSell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(resShopSell& a, resShopSell& b) {
    a.Swap(&b);
  }
  inline void Swap(resShopSell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resShopSell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resShopSell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resShopSell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resShopSell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resShopSell& from) {
    resShopSell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resShopSell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKPacket.resShopSell";
  }
  protected:
  explicit resShopSell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CKPacket.resShopSell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_item_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// resPlayerJoin

// -------------------------------------------------------------------

// reqPing

// -------------------------------------------------------------------

// resPing

// -------------------------------------------------------------------

// reqNotifyPlayerName

// string name = 1;
inline void reqNotifyPlayerName::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& reqNotifyPlayerName::name() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqNotifyPlayerName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void reqNotifyPlayerName::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.reqNotifyPlayerName.name)
}
inline std::string* reqNotifyPlayerName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CKPacket.reqNotifyPlayerName.name)
  return _s;
}
inline const std::string& reqNotifyPlayerName::_internal_name() const {
  return _impl_.name_.Get();
}
inline void reqNotifyPlayerName::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* reqNotifyPlayerName::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* reqNotifyPlayerName::release_name() {
  // @@protoc_insertion_point(field_release:CKPacket.reqNotifyPlayerName.name)
  return _impl_.name_.Release();
}
inline void reqNotifyPlayerName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.reqNotifyPlayerName.name)
}

// -------------------------------------------------------------------

// reqPlayerPosition

// optional float x = 1;
inline bool reqPlayerPosition::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool reqPlayerPosition::has_x() const {
  return _internal_has_x();
}
inline void reqPlayerPosition::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float reqPlayerPosition::_internal_x() const {
  return _impl_.x_;
}
inline float reqPlayerPosition::x() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqPlayerPosition.x)
  return _internal_x();
}
inline void reqPlayerPosition::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void reqPlayerPosition::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqPlayerPosition.x)
}

// optional float y = 2;
inline bool reqPlayerPosition::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool reqPlayerPosition::has_y() const {
  return _internal_has_y();
}
inline void reqPlayerPosition::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float reqPlayerPosition::_internal_y() const {
  return _impl_.y_;
}
inline float reqPlayerPosition::y() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqPlayerPosition.y)
  return _internal_y();
}
inline void reqPlayerPosition::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void reqPlayerPosition::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqPlayerPosition.y)
}

// optional float z = 3;
inline bool reqPlayerPosition::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool reqPlayerPosition::has_z() const {
  return _internal_has_z();
}
inline void reqPlayerPosition::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float reqPlayerPosition::_internal_z() const {
  return _impl_.z_;
}
inline float reqPlayerPosition::z() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqPlayerPosition.z)
  return _internal_z();
}
inline void reqPlayerPosition::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void reqPlayerPosition::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqPlayerPosition.z)
}

// optional int32 index = 4;
inline bool reqPlayerPosition::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool reqPlayerPosition::has_index() const {
  return _internal_has_index();
}
inline void reqPlayerPosition::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t reqPlayerPosition::_internal_index() const {
  return _impl_.index_;
}
inline int32_t reqPlayerPosition::index() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqPlayerPosition.index)
  return _internal_index();
}
inline void reqPlayerPosition::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.index_ = value;
}
inline void reqPlayerPosition::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqPlayerPosition.index)
}

// -------------------------------------------------------------------

// resPlayerPosition

// optional float x = 1;
inline bool resPlayerPosition::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resPlayerPosition::has_x() const {
  return _internal_has_x();
}
inline void resPlayerPosition::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float resPlayerPosition::_internal_x() const {
  return _impl_.x_;
}
inline float resPlayerPosition::x() const {
  // @@protoc_insertion_point(field_get:CKPacket.resPlayerPosition.x)
  return _internal_x();
}
inline void resPlayerPosition::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void resPlayerPosition::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CKPacket.resPlayerPosition.x)
}

// optional float y = 2;
inline bool resPlayerPosition::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool resPlayerPosition::has_y() const {
  return _internal_has_y();
}
inline void resPlayerPosition::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float resPlayerPosition::_internal_y() const {
  return _impl_.y_;
}
inline float resPlayerPosition::y() const {
  // @@protoc_insertion_point(field_get:CKPacket.resPlayerPosition.y)
  return _internal_y();
}
inline void resPlayerPosition::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void resPlayerPosition::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CKPacket.resPlayerPosition.y)
}

// optional float z = 3;
inline bool resPlayerPosition::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool resPlayerPosition::has_z() const {
  return _internal_has_z();
}
inline void resPlayerPosition::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float resPlayerPosition::_internal_z() const {
  return _impl_.z_;
}
inline float resPlayerPosition::z() const {
  // @@protoc_insertion_point(field_get:CKPacket.resPlayerPosition.z)
  return _internal_z();
}
inline void resPlayerPosition::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void resPlayerPosition::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:CKPacket.resPlayerPosition.z)
}

// optional int32 index = 4;
inline bool resPlayerPosition::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool resPlayerPosition::has_index() const {
  return _internal_has_index();
}
inline void resPlayerPosition::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t resPlayerPosition::_internal_index() const {
  return _impl_.index_;
}
inline int32_t resPlayerPosition::index() const {
  // @@protoc_insertion_point(field_get:CKPacket.resPlayerPosition.index)
  return _internal_index();
}
inline void resPlayerPosition::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.index_ = value;
}
inline void resPlayerPosition::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:CKPacket.resPlayerPosition.index)
}

// -------------------------------------------------------------------

// resReplicatedPlayerGen

// optional int32 index = 1;
inline bool resReplicatedPlayerGen::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resReplicatedPlayerGen::has_index() const {
  return _internal_has_index();
}
inline void resReplicatedPlayerGen::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t resReplicatedPlayerGen::_internal_index() const {
  return _impl_.index_;
}
inline int32_t resReplicatedPlayerGen::index() const {
  // @@protoc_insertion_point(field_get:CKPacket.resReplicatedPlayerGen.index)
  return _internal_index();
}
inline void resReplicatedPlayerGen::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.index_ = value;
}
inline void resReplicatedPlayerGen::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:CKPacket.resReplicatedPlayerGen.index)
}

// -------------------------------------------------------------------

// resReplicatedPlayerDes

// optional int32 index = 1;
inline bool resReplicatedPlayerDes::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resReplicatedPlayerDes::has_index() const {
  return _internal_has_index();
}
inline void resReplicatedPlayerDes::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t resReplicatedPlayerDes::_internal_index() const {
  return _impl_.index_;
}
inline int32_t resReplicatedPlayerDes::index() const {
  // @@protoc_insertion_point(field_get:CKPacket.resReplicatedPlayerDes.index)
  return _internal_index();
}
inline void resReplicatedPlayerDes::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.index_ = value;
}
inline void resReplicatedPlayerDes::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:CKPacket.resReplicatedPlayerDes.index)
}

// -------------------------------------------------------------------

// reqReplicatedPlayerGen

// -------------------------------------------------------------------

// reqReplicatedPlayerDes

// optional int32 index = 1;
inline bool reqReplicatedPlayerDes::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool reqReplicatedPlayerDes::has_index() const {
  return _internal_has_index();
}
inline void reqReplicatedPlayerDes::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t reqReplicatedPlayerDes::_internal_index() const {
  return _impl_.index_;
}
inline int32_t reqReplicatedPlayerDes::index() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqReplicatedPlayerDes.index)
  return _internal_index();
}
inline void reqReplicatedPlayerDes::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.index_ = value;
}
inline void reqReplicatedPlayerDes::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqReplicatedPlayerDes.index)
}

// -------------------------------------------------------------------

// reqAddToItem

// .CKPacket.itemInfo item = 1;
inline bool reqAddToItem::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool reqAddToItem::has_item() const {
  return _internal_has_item();
}
inline void reqAddToItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::CKPacket::itemInfo& reqAddToItem::_internal_item() const {
  const ::CKPacket::itemInfo* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::CKPacket::itemInfo&>(
      ::CKPacket::_itemInfo_default_instance_);
}
inline const ::CKPacket::itemInfo& reqAddToItem::item() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqAddToItem.item)
  return _internal_item();
}
inline void reqAddToItem::unsafe_arena_set_allocated_item(
    ::CKPacket::itemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CKPacket.reqAddToItem.item)
}
inline ::CKPacket::itemInfo* reqAddToItem::release_item() {
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CKPacket::itemInfo* reqAddToItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:CKPacket.reqAddToItem.item)
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::CKPacket::itemInfo* reqAddToItem::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::CKPacket::itemInfo>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::CKPacket::itemInfo* reqAddToItem::mutable_item() {
  ::CKPacket::itemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:CKPacket.reqAddToItem.item)
  return _msg;
}
inline void reqAddToItem::set_allocated_item(::CKPacket::itemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:CKPacket.reqAddToItem.item)
}

// -------------------------------------------------------------------

// resAddToItem

// .CKPacket.itemInfo item = 1;
inline bool resAddToItem::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool resAddToItem::has_item() const {
  return _internal_has_item();
}
inline void resAddToItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::CKPacket::itemInfo& resAddToItem::_internal_item() const {
  const ::CKPacket::itemInfo* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::CKPacket::itemInfo&>(
      ::CKPacket::_itemInfo_default_instance_);
}
inline const ::CKPacket::itemInfo& resAddToItem::item() const {
  // @@protoc_insertion_point(field_get:CKPacket.resAddToItem.item)
  return _internal_item();
}
inline void resAddToItem::unsafe_arena_set_allocated_item(
    ::CKPacket::itemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CKPacket.resAddToItem.item)
}
inline ::CKPacket::itemInfo* resAddToItem::release_item() {
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CKPacket::itemInfo* resAddToItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:CKPacket.resAddToItem.item)
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::CKPacket::itemInfo* resAddToItem::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::CKPacket::itemInfo>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::CKPacket::itemInfo* resAddToItem::mutable_item() {
  ::CKPacket::itemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:CKPacket.resAddToItem.item)
  return _msg;
}
inline void resAddToItem::set_allocated_item(::CKPacket::itemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:CKPacket.resAddToItem.item)
}

// -------------------------------------------------------------------

// reqRemoveFromItem

// .CKPacket.itemInfo item = 1;
inline bool reqRemoveFromItem::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool reqRemoveFromItem::has_item() const {
  return _internal_has_item();
}
inline void reqRemoveFromItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::CKPacket::itemInfo& reqRemoveFromItem::_internal_item() const {
  const ::CKPacket::itemInfo* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::CKPacket::itemInfo&>(
      ::CKPacket::_itemInfo_default_instance_);
}
inline const ::CKPacket::itemInfo& reqRemoveFromItem::item() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqRemoveFromItem.item)
  return _internal_item();
}
inline void reqRemoveFromItem::unsafe_arena_set_allocated_item(
    ::CKPacket::itemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CKPacket.reqRemoveFromItem.item)
}
inline ::CKPacket::itemInfo* reqRemoveFromItem::release_item() {
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CKPacket::itemInfo* reqRemoveFromItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:CKPacket.reqRemoveFromItem.item)
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::CKPacket::itemInfo* reqRemoveFromItem::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::CKPacket::itemInfo>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::CKPacket::itemInfo* reqRemoveFromItem::mutable_item() {
  ::CKPacket::itemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:CKPacket.reqRemoveFromItem.item)
  return _msg;
}
inline void reqRemoveFromItem::set_allocated_item(::CKPacket::itemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:CKPacket.reqRemoveFromItem.item)
}

// -------------------------------------------------------------------

// resRemoveFromToItem

// .CKPacket.itemInfo item = 1;
inline bool resRemoveFromToItem::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool resRemoveFromToItem::has_item() const {
  return _internal_has_item();
}
inline void resRemoveFromToItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::CKPacket::itemInfo& resRemoveFromToItem::_internal_item() const {
  const ::CKPacket::itemInfo* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::CKPacket::itemInfo&>(
      ::CKPacket::_itemInfo_default_instance_);
}
inline const ::CKPacket::itemInfo& resRemoveFromToItem::item() const {
  // @@protoc_insertion_point(field_get:CKPacket.resRemoveFromToItem.item)
  return _internal_item();
}
inline void resRemoveFromToItem::unsafe_arena_set_allocated_item(
    ::CKPacket::itemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CKPacket.resRemoveFromToItem.item)
}
inline ::CKPacket::itemInfo* resRemoveFromToItem::release_item() {
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CKPacket::itemInfo* resRemoveFromToItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:CKPacket.resRemoveFromToItem.item)
  
  ::CKPacket::itemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::CKPacket::itemInfo* resRemoveFromToItem::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::CKPacket::itemInfo>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::CKPacket::itemInfo* resRemoveFromToItem::mutable_item() {
  ::CKPacket::itemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:CKPacket.resRemoveFromToItem.item)
  return _msg;
}
inline void resRemoveFromToItem::set_allocated_item(::CKPacket::itemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:CKPacket.resRemoveFromToItem.item)
}

// -------------------------------------------------------------------

// reqInventoryItems

// string name = 1;
inline void reqInventoryItems::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& reqInventoryItems::name() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqInventoryItems.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void reqInventoryItems::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.reqInventoryItems.name)
}
inline std::string* reqInventoryItems::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CKPacket.reqInventoryItems.name)
  return _s;
}
inline const std::string& reqInventoryItems::_internal_name() const {
  return _impl_.name_.Get();
}
inline void reqInventoryItems::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* reqInventoryItems::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* reqInventoryItems::release_name() {
  // @@protoc_insertion_point(field_release:CKPacket.reqInventoryItems.name)
  return _impl_.name_.Release();
}
inline void reqInventoryItems::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.reqInventoryItems.name)
}

// -------------------------------------------------------------------

// resInventoryItems

// repeated .CKPacket.itemInfo items = 1;
inline int resInventoryItems::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int resInventoryItems::items_size() const {
  return _internal_items_size();
}
inline void resInventoryItems::clear_items() {
  _impl_.items_.Clear();
}
inline ::CKPacket::itemInfo* resInventoryItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:CKPacket.resInventoryItems.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::itemInfo >*
resInventoryItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:CKPacket.resInventoryItems.items)
  return &_impl_.items_;
}
inline const ::CKPacket::itemInfo& resInventoryItems::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::CKPacket::itemInfo& resInventoryItems::items(int index) const {
  // @@protoc_insertion_point(field_get:CKPacket.resInventoryItems.items)
  return _internal_items(index);
}
inline ::CKPacket::itemInfo* resInventoryItems::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::CKPacket::itemInfo* resInventoryItems::add_items() {
  ::CKPacket::itemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:CKPacket.resInventoryItems.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::itemInfo >&
resInventoryItems::items() const {
  // @@protoc_insertion_point(field_list:CKPacket.resInventoryItems.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// itemInfo

// int32 itemid = 1;
inline void itemInfo::clear_itemid() {
  _impl_.itemid_ = 0;
}
inline int32_t itemInfo::_internal_itemid() const {
  return _impl_.itemid_;
}
inline int32_t itemInfo::itemid() const {
  // @@protoc_insertion_point(field_get:CKPacket.itemInfo.itemid)
  return _internal_itemid();
}
inline void itemInfo::_internal_set_itemid(int32_t value) {
  
  _impl_.itemid_ = value;
}
inline void itemInfo::set_itemid(int32_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:CKPacket.itemInfo.itemid)
}

// string itemName = 2;
inline void itemInfo::clear_itemname() {
  _impl_.itemname_.ClearToEmpty();
}
inline const std::string& itemInfo::itemname() const {
  // @@protoc_insertion_point(field_get:CKPacket.itemInfo.itemName)
  return _internal_itemname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void itemInfo::set_itemname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.itemname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.itemInfo.itemName)
}
inline std::string* itemInfo::mutable_itemname() {
  std::string* _s = _internal_mutable_itemname();
  // @@protoc_insertion_point(field_mutable:CKPacket.itemInfo.itemName)
  return _s;
}
inline const std::string& itemInfo::_internal_itemname() const {
  return _impl_.itemname_.Get();
}
inline void itemInfo::_internal_set_itemname(const std::string& value) {
  
  _impl_.itemname_.Set(value, GetArenaForAllocation());
}
inline std::string* itemInfo::_internal_mutable_itemname() {
  
  return _impl_.itemname_.Mutable(GetArenaForAllocation());
}
inline std::string* itemInfo::release_itemname() {
  // @@protoc_insertion_point(field_release:CKPacket.itemInfo.itemName)
  return _impl_.itemname_.Release();
}
inline void itemInfo::set_allocated_itemname(std::string* itemname) {
  if (itemname != nullptr) {
    
  } else {
    
  }
  _impl_.itemname_.SetAllocated(itemname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.itemname_.IsDefault()) {
    _impl_.itemname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.itemInfo.itemName)
}

// string itemDesc = 3;
inline void itemInfo::clear_itemdesc() {
  _impl_.itemdesc_.ClearToEmpty();
}
inline const std::string& itemInfo::itemdesc() const {
  // @@protoc_insertion_point(field_get:CKPacket.itemInfo.itemDesc)
  return _internal_itemdesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void itemInfo::set_itemdesc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.itemdesc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.itemInfo.itemDesc)
}
inline std::string* itemInfo::mutable_itemdesc() {
  std::string* _s = _internal_mutable_itemdesc();
  // @@protoc_insertion_point(field_mutable:CKPacket.itemInfo.itemDesc)
  return _s;
}
inline const std::string& itemInfo::_internal_itemdesc() const {
  return _impl_.itemdesc_.Get();
}
inline void itemInfo::_internal_set_itemdesc(const std::string& value) {
  
  _impl_.itemdesc_.Set(value, GetArenaForAllocation());
}
inline std::string* itemInfo::_internal_mutable_itemdesc() {
  
  return _impl_.itemdesc_.Mutable(GetArenaForAllocation());
}
inline std::string* itemInfo::release_itemdesc() {
  // @@protoc_insertion_point(field_release:CKPacket.itemInfo.itemDesc)
  return _impl_.itemdesc_.Release();
}
inline void itemInfo::set_allocated_itemdesc(std::string* itemdesc) {
  if (itemdesc != nullptr) {
    
  } else {
    
  }
  _impl_.itemdesc_.SetAllocated(itemdesc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.itemdesc_.IsDefault()) {
    _impl_.itemdesc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.itemInfo.itemDesc)
}

// uint32 count = 4;
inline void itemInfo::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t itemInfo::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t itemInfo::count() const {
  // @@protoc_insertion_point(field_get:CKPacket.itemInfo.count)
  return _internal_count();
}
inline void itemInfo::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void itemInfo::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CKPacket.itemInfo.count)
}

// -------------------------------------------------------------------

// reqShopItemList

// -------------------------------------------------------------------

// resShopItemList

// repeated .CKPacket.shopItem items = 1;
inline int resShopItemList::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int resShopItemList::items_size() const {
  return _internal_items_size();
}
inline void resShopItemList::clear_items() {
  _impl_.items_.Clear();
}
inline ::CKPacket::shopItem* resShopItemList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:CKPacket.resShopItemList.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::shopItem >*
resShopItemList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:CKPacket.resShopItemList.items)
  return &_impl_.items_;
}
inline const ::CKPacket::shopItem& resShopItemList::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::CKPacket::shopItem& resShopItemList::items(int index) const {
  // @@protoc_insertion_point(field_get:CKPacket.resShopItemList.items)
  return _internal_items(index);
}
inline ::CKPacket::shopItem* resShopItemList::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::CKPacket::shopItem* resShopItemList::add_items() {
  ::CKPacket::shopItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:CKPacket.resShopItemList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CKPacket::shopItem >&
resShopItemList::items() const {
  // @@protoc_insertion_point(field_list:CKPacket.resShopItemList.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// shopItem

// int32 itemId = 1;
inline void shopItem::clear_itemid() {
  _impl_.itemid_ = 0;
}
inline int32_t shopItem::_internal_itemid() const {
  return _impl_.itemid_;
}
inline int32_t shopItem::itemid() const {
  // @@protoc_insertion_point(field_get:CKPacket.shopItem.itemId)
  return _internal_itemid();
}
inline void shopItem::_internal_set_itemid(int32_t value) {
  
  _impl_.itemid_ = value;
}
inline void shopItem::set_itemid(int32_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:CKPacket.shopItem.itemId)
}

// string itemName = 2;
inline void shopItem::clear_itemname() {
  _impl_.itemname_.ClearToEmpty();
}
inline const std::string& shopItem::itemname() const {
  // @@protoc_insertion_point(field_get:CKPacket.shopItem.itemName)
  return _internal_itemname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void shopItem::set_itemname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.itemname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.shopItem.itemName)
}
inline std::string* shopItem::mutable_itemname() {
  std::string* _s = _internal_mutable_itemname();
  // @@protoc_insertion_point(field_mutable:CKPacket.shopItem.itemName)
  return _s;
}
inline const std::string& shopItem::_internal_itemname() const {
  return _impl_.itemname_.Get();
}
inline void shopItem::_internal_set_itemname(const std::string& value) {
  
  _impl_.itemname_.Set(value, GetArenaForAllocation());
}
inline std::string* shopItem::_internal_mutable_itemname() {
  
  return _impl_.itemname_.Mutable(GetArenaForAllocation());
}
inline std::string* shopItem::release_itemname() {
  // @@protoc_insertion_point(field_release:CKPacket.shopItem.itemName)
  return _impl_.itemname_.Release();
}
inline void shopItem::set_allocated_itemname(std::string* itemname) {
  if (itemname != nullptr) {
    
  } else {
    
  }
  _impl_.itemname_.SetAllocated(itemname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.itemname_.IsDefault()) {
    _impl_.itemname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.shopItem.itemName)
}

// string itemDesc = 3;
inline void shopItem::clear_itemdesc() {
  _impl_.itemdesc_.ClearToEmpty();
}
inline const std::string& shopItem::itemdesc() const {
  // @@protoc_insertion_point(field_get:CKPacket.shopItem.itemDesc)
  return _internal_itemdesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void shopItem::set_itemdesc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.itemdesc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.shopItem.itemDesc)
}
inline std::string* shopItem::mutable_itemdesc() {
  std::string* _s = _internal_mutable_itemdesc();
  // @@protoc_insertion_point(field_mutable:CKPacket.shopItem.itemDesc)
  return _s;
}
inline const std::string& shopItem::_internal_itemdesc() const {
  return _impl_.itemdesc_.Get();
}
inline void shopItem::_internal_set_itemdesc(const std::string& value) {
  
  _impl_.itemdesc_.Set(value, GetArenaForAllocation());
}
inline std::string* shopItem::_internal_mutable_itemdesc() {
  
  return _impl_.itemdesc_.Mutable(GetArenaForAllocation());
}
inline std::string* shopItem::release_itemdesc() {
  // @@protoc_insertion_point(field_release:CKPacket.shopItem.itemDesc)
  return _impl_.itemdesc_.Release();
}
inline void shopItem::set_allocated_itemdesc(std::string* itemdesc) {
  if (itemdesc != nullptr) {
    
  } else {
    
  }
  _impl_.itemdesc_.SetAllocated(itemdesc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.itemdesc_.IsDefault()) {
    _impl_.itemdesc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.shopItem.itemDesc)
}

// int32 itemCount = 4;
inline void shopItem::clear_itemcount() {
  _impl_.itemcount_ = 0;
}
inline int32_t shopItem::_internal_itemcount() const {
  return _impl_.itemcount_;
}
inline int32_t shopItem::itemcount() const {
  // @@protoc_insertion_point(field_get:CKPacket.shopItem.itemCount)
  return _internal_itemcount();
}
inline void shopItem::_internal_set_itemcount(int32_t value) {
  
  _impl_.itemcount_ = value;
}
inline void shopItem::set_itemcount(int32_t value) {
  _internal_set_itemcount(value);
  // @@protoc_insertion_point(field_set:CKPacket.shopItem.itemCount)
}

// -------------------------------------------------------------------

// reqShopBuy

// string playerName = 1;
inline void reqShopBuy::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& reqShopBuy::playername() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqShopBuy.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void reqShopBuy::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.reqShopBuy.playerName)
}
inline std::string* reqShopBuy::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:CKPacket.reqShopBuy.playerName)
  return _s;
}
inline const std::string& reqShopBuy::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void reqShopBuy::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* reqShopBuy::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* reqShopBuy::release_playername() {
  // @@protoc_insertion_point(field_release:CKPacket.reqShopBuy.playerName)
  return _impl_.playername_.Release();
}
inline void reqShopBuy::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.reqShopBuy.playerName)
}

// int32 itemID = 2;
inline void reqShopBuy::clear_itemid() {
  _impl_.itemid_ = 0;
}
inline int32_t reqShopBuy::_internal_itemid() const {
  return _impl_.itemid_;
}
inline int32_t reqShopBuy::itemid() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqShopBuy.itemID)
  return _internal_itemid();
}
inline void reqShopBuy::_internal_set_itemid(int32_t value) {
  
  _impl_.itemid_ = value;
}
inline void reqShopBuy::set_itemid(int32_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqShopBuy.itemID)
}

// int32 count = 3;
inline void reqShopBuy::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t reqShopBuy::_internal_count() const {
  return _impl_.count_;
}
inline int32_t reqShopBuy::count() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqShopBuy.count)
  return _internal_count();
}
inline void reqShopBuy::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void reqShopBuy::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqShopBuy.count)
}

// -------------------------------------------------------------------

// resShopBuy

// bool success = 1;
inline void resShopBuy::clear_success() {
  _impl_.success_ = false;
}
inline bool resShopBuy::_internal_success() const {
  return _impl_.success_;
}
inline bool resShopBuy::success() const {
  // @@protoc_insertion_point(field_get:CKPacket.resShopBuy.success)
  return _internal_success();
}
inline void resShopBuy::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void resShopBuy::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:CKPacket.resShopBuy.success)
}

// -------------------------------------------------------------------

// reqShopSell

// string playerName = 1;
inline void reqShopSell::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& reqShopSell::playername() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqShopSell.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void reqShopSell::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CKPacket.reqShopSell.playerName)
}
inline std::string* reqShopSell::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:CKPacket.reqShopSell.playerName)
  return _s;
}
inline const std::string& reqShopSell::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void reqShopSell::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* reqShopSell::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* reqShopSell::release_playername() {
  // @@protoc_insertion_point(field_release:CKPacket.reqShopSell.playerName)
  return _impl_.playername_.Release();
}
inline void reqShopSell::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CKPacket.reqShopSell.playerName)
}

// int32 itemID = 2;
inline void reqShopSell::clear_itemid() {
  _impl_.itemid_ = 0;
}
inline int32_t reqShopSell::_internal_itemid() const {
  return _impl_.itemid_;
}
inline int32_t reqShopSell::itemid() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqShopSell.itemID)
  return _internal_itemid();
}
inline void reqShopSell::_internal_set_itemid(int32_t value) {
  
  _impl_.itemid_ = value;
}
inline void reqShopSell::set_itemid(int32_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqShopSell.itemID)
}

// int32 count = 3;
inline void reqShopSell::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t reqShopSell::_internal_count() const {
  return _impl_.count_;
}
inline int32_t reqShopSell::count() const {
  // @@protoc_insertion_point(field_get:CKPacket.reqShopSell.count)
  return _internal_count();
}
inline void reqShopSell::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void reqShopSell::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CKPacket.reqShopSell.count)
}

// -------------------------------------------------------------------

// resShopSell

// bool success = 1;
inline void resShopSell::clear_success() {
  _impl_.success_ = false;
}
inline bool resShopSell::_internal_success() const {
  return _impl_.success_;
}
inline bool resShopSell::success() const {
  // @@protoc_insertion_point(field_get:CKPacket.resShopSell.success)
  return _internal_success();
}
inline void resShopSell::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void resShopSell::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:CKPacket.resShopSell.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CKPacket

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_item_2eproto
